from __future__ import division, print_function

import numpy as np
from numpy.linalg import norm
from .restraint import Restraint
from ..model.forces import HarmonicUpperBound, HarmonicLowerBound
from ..model.particle import Particle

import h5py
from ..utils.log import logger

# helper functions

def sort_radially(ii, crd):

    """ Sort radial distances of multiploid annotations [k, k + n_hapl], listed in ii """

    ii = np.array(ii)
    dists = [ norm(crd[i]) for i in ii ]    # compute an array of radial distances (from geometric center)
    return ii[np.argsort(dists)]

def sort_pairs_by_distance(ii, jj, crd):

    """ Sort pairwise distances of multiploid annotations [(i, j), (i, j + n_hapl), (i + n_hapl, j), (i + n_hapl, j + n_hapl)], listed in pairs """

    # value depends on genome ploidity
    n_combinations = len(ii)*len(jj)
    dists = np.zeros(n_combinations)
    pairs = np.zeros((n_combinations, 2), dtype = int)
    it = 0     # this is a counter
    for m in ii:
        for n in jj:
            x = crd[m]
            y = crd[n] 
            dists[it] = norm(x - y)    # distance between n and m
            pairs[it, :] = [m, n]
            it += 1

    # return the list of domain pairs accorting to sorted pairwise distances
    return pairs[np.argsort(dists), :]


class Fish(Restraint):

    """
    Object handles FISH restraint: add list of pair forces to append to igm.model.forces
    
    Parameters
    ----------
    fish_assignment_file : h5df - file list generated by the Assignment Step, dictionary consists of:
		           {'probes',  'radial_min', 'radial_max'         (radial distances, one body)
		             'pairs',    'pair_min',   'pair_max'}        (pairwise distances, two body)
    struct_id : index of structure in population
    index:      alabtools Index object (go from haploid to multiploid annotations)
    rtype:      string, 'r' or 'R' (RADIAL), 'p' or 'P' (PAIR), and combinations
    tolerance:  tolerance parameter to impose distances
    kspring:    FISH restraining constant
    
    Read in a fish_file generated from the AssignmentStep, from haploid to diploid annotations, select min or max pair (probe), apply restraints
    """
    
    def __init__(self, 
                 fish_assignment_file,
                 index, 
                 struct_id,
                 rtype,
                 tolerance = 10.0, 
                 kspring = 2.0 ):
        
        self.fish_assignment_file = fish_assignment_file

        self.hff                  = h5py.File(self.fish_assignment_file, 'r')

        self.rtype                = rtype
        self.index                = index
        self.struct_id            = struct_id
        self.tolerance            = tolerance
        self.kspring              = kspring
        
        # list to which FISH restraints are appended to the model object
        self.forceID   = []

   
        
    def _apply(self, model):
        
            # copy index, includes the diploid annotations
            copy_index = self.index.copy_index

            minradial = 'r' in self.rtype    # minimal radial distance (particle to center)
            maxradial = 'R' in self.rtype    # maximal radial distance (particle to center)
            minpair   = 'p' in self.rtype      # minimal pairwise distance (particle to particle)
            maxpair   = 'P' in self.rtype      # maximal pairwise distance (particle to particle)

            struct_id = self.struct_id

            ck        = self.kspring
            tol       = self.tolerance
            crd       = model.getCoordinates()     # IGM model, this is where coordinates are directly processed
                                               # only coordinates associated with structure "struct_id" are read in 
            hff       = self.hff

            logger.info("tolerance = " + str(tol))
            logger.info("constant  = " + str(ck))
            logger.info("crd      = " + str(crd.shape))
       
            logger.info("Using " + self.rtype + " FISH protocol")
 
            # if we use radial restraint we want to define the center, let's add a DUMMY particle
            if minradial or maxradial:
               center = model.addParticle([0., 0., 0.], 0., Particle.DUMMY_STATIC)

            if minradial:

               probes  = hff['probes'][()]
               targets = hff['radial_min'][:, struct_id][()]   # select only those "target_distance"s pertaining such a structure
   
               for q, i in enumerate(probes):
                
                    # get all the copies of locus i
                    ii = copy_index[i]  
                    target_dist = targets[q]

                    # find the one locus being closest to the center
                    particle = sort_radially(ii, crd)[0]

                    # add a lower bound on that bead
                    f = HarmonicLowerBound((center, particle), 
                                       k=ck,
                                       d=max(0, target_dist - tol),    # is the target_dist very close to the tolerance?
                                       note=Restraint.FISH_RADIAL)
                    f = model.addForce(f)
                    self.forceID.append(f)

                    # add a upper bound on that bead
                    f = HarmonicUpperBound((center, particle), 
                                       k=ck,
                                       d=target_dist + tol,
                                       note=Restraint.FISH_RADIAL)
                    f = model.addForce(f)
                    self.forceID.append(f)

                    # push the other domain outwards, we do not want it to accidentally get further away from target_dist
                    other_particle = sort_radially(ii, crd)[-1]

                    # add restraint to keep other particle closer to the center, within threshold value
                    f = model.addForce(HarmonicLowerBound((center, other_particle),
                                       k=ck,
                                       d=target_dist + tol,
                                       note=Restraint.FISH_RADIAL))
                    self.forceID.append(f)


            if maxradial:

               probes  = hff['probes'][()]
               targets = hff['radial_max'][:, struct_id][()]

               for q, i in enumerate(probes):
                    # get all multiploid copies of locus i
                    ii = copy_index[i]
                    target_dist = targets[q]

                    # find the one locus being farthest away from the center
                    particle = sort_radially(ii, crd)[-1]

                    # add a lower bound on that bead
                    f = model.addForce(HarmonicLowerBound((center, particle), 
                                       k=ck,
                                       d=max(0, target_dist - tol),
                                       note=Restraint.FISH_RADIAL))
                    self.forceID.append(f)

                    # add a upper bound on that bead
                    f = model.addForce(HarmonicUpperBound((center, particle), 
                                       k=ck,
                                       d=target_dist + tol,
                                       note=Restraint.FISH_RADIAL))
                    self.forceID.append(f)

                    # push the other domain inwards, we do not want it to accidentally get further away from target_dist
                    other_particle = sort_radially(ii, crd)[0]

                    # add restraint to keep other particle closer to the center, within threshold value
                    f = model.addForce(HarmonicUpperBound((center, other_particle),
                                       k=ck,
                                       d=target_dist - tol,
                                       note=Restraint.FISH_RADIAL))
                    self.forceID.append(f)

            if minpair:

                pairs   = hff['pairs'][()]
                targets = hff['pair_min'][:, struct_id][()]

                for q, (i, j) in enumerate(pairs):
                   assert (i != j)

                   target_dist = targets[q]

                   # get annotations from  all the copies
                   ii = copy_index[i]
                   jj = copy_index[j]

                   # sort all the possible multiploid pairs by distance
                   sorted_pairs = sort_pairs_by_distance(ii, jj, crd)
                
                   # restraint all the pairs not to be too close
                   for m, n in sorted_pairs:    
                      f = HarmonicLowerBound((m, n), 
                                           k=ck,
                                           d=max(0, target_dist - tol),
                                           note=Restraint.FISH_PAIR)
                      f = model.addForce(f)
                      self.forceID.append(f)
            

                   # find the closest pair and keep it from getting
                   # too far apart, keep em closer than (target+tol)

                   m, n = sorted_pairs[0]
                   f = HarmonicUpperBound((m, n), 
                                       k=ck,
                                       d=target_dist + tol,
                                       note=Restraint.FISH_PAIR)
                   f = model.addForce(f)
                   self.forceID.append(f)
                
            if maxpair:

               pairs   = hff['pairs'][()]
               targets = hff['pair_max'][:, struct_id][()]

               for q, (i, j) in enumerate(pairs):
                
                   assert (i != j)
                   target_dist = targets[q]

                   # get annotations from all the copies
                   ii = copy_index[i]
                   jj = copy_index[j]

                   # sort all the possible multiploid pairs by distance
                   sorted_pairs = sort_pairs_by_distance(ii, jj, crd)
                
                   # restraint all the pairs not to be too far: upper bound, with ck elastic constant, rest length within "tol" tolerance
                   for m, n in sorted_pairs:    
                      f = HarmonicUpperBound((m, n), 
                                           k=ck,
                                           d=target_dist + tol,
                                           note=Restraint.FISH_PAIR)
                      f = model.addForce(f)
                      self.forceID.append(f)
            

                   # find the furthest pair and keep it from getting
                   # too close to each other (look into this)
                   m, n = sorted_pairs[-1]
                   f = HarmonicLowerBound((m, n), 
                                       k=ck,
                                       d=max(0, target_dist - tol),
                                       note=Restraint.FISH_PAIR)
                   f = model.addForce(f)
                   self.forceID.append(f)

            hff.close()
    
#==
